---
title: "Intro to ggplot"
author: "James Van Slyke"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo =TRUE)
library(tidyverse)
data(mpg)
data("diamonds")
data(Example)
```

## Using `ggplot`

`ggplot` is a graphics language that we use to make graphs. The text we will use for our first go at making graphs is called *R for Data Science*

Like a lot of other attractive things about R and R Studio the book is free!! and probably one of the best resources for understanding R and Data.

You can find the book [here](https://r4ds.had.co.nz/index.html)

I'll be using several modified examples from [Chapter 3](https://r4ds.had.co.nz/) of that book.

## *The* Tidyverse

Tidyverse is a package we'll be using throughout our exploration of statistics. There are lots of great helps for doing data science.

First you'll want to load "tidyverse" as a package. Here's how we find and load packages in R Studio.

1.  Search under "Packages" in the bottom right window

2.  Click on install and search for tidyverse in the CRAN repository

3.  Once you've found tidyverse, click on install - It may take some time for the package to download and install - wait until it is all done.

4.  Once the package is downloaded just make sure to check next to the package on your list of packages OR simply use this code.

    ```{r}
    library(tidyverse)
    ```

### `mpg` dataset

We'll start off by using a dataset called "mpg" It should have loaded with the tidyverse package. Just type it in to find it

```{r eval=TRUE}
mpg
```

It shows the dataset as a "tibble", which just means table in the tidyverse

Because it's a preloaded dataset we can get information about it by using a question mark. A question mark in front of any command in R will automatically generate the help file

```{r, eval=TRUE}
?mpg
```

## Levels of Measurement

-   *Categorical*
    -   **Binary variable**
    -   **Nominal variable**
    -   **Ordinal variable**
-   *Continuous*
    -   **Interval variable**
    -   **Ratio variable**

Datasets contain several different variables. Notice in the mpg dataset, there are several different variables such as *model*, *year*, *cty*, and *hwy*. The `str` command shows all the different variables.

```{r}
str(mpg)
```

These are several different types of variables because they represent different kinds of things. In statistics we refer to this as *levels of measurement*. There are two broad types of variables, *categorical* and *continuous* (Field, 2009, pages 8-9). Categorical variables are based on particular categories, such a type of shoe, religious affiliation, or political affiliation. A **binary** variable is a type of categorical variable that only takes two categories. So things like being pregnant or not, voting yes or no on a certain bill, or being alive or dead are binary variables, there are only two possible things in the category. Categorical variables that take on more than 2 possibilities are called **nominal** variables (nominal means names)

### Categorical

There's no mathematics involved in determining categorical variables, it's simply based on which category has the most accurate fit. Either you are a republican, democrat, or independent, there is no mathematical quantity that would determine the appropriate category. There is one type of categorical variable that is ordered based on the absence or presence of a particular property, which is an **ordinal** variable. Ordinal variables have a particular rank order, but the rankings are *not* equal or uniform. So for example, college basketball team rankings would be an ordinal variable. The teams are ranked from best to worst, but team #2 may be twice is good as team #3, while team #5 maybe four times as good as team #6. So ordinal data tells us more about the variable than nominal data, but it still doesn't provide a standardized scale of measurement.

### Continuous

*Continuous* variables are the second broad category and involves some type of numerical measurement to define the property in the variable. Continuous variables can take on any value in the measurement scale defined by the variable. The first example of this type variable is an **interval** variable. These types of variables are based on a measurement scale with equal distances between the ranks based on the property measured; equal intervals in the scale are able to represent equal differences in the variable being measured. The Fahrenheit scale would be an interval scale because the difference in degree between 64 and 65 is the same as 74 and 75.

### Ratio

**Ratio** variables add one more dimension to the properties of an interval variable. In addition to having an equal distance in ranks, ratios have an absolute zero point. This allows for multiplication of the intervals or the use of ratios. So on a ratio scale of 0 to 5, a score of 4 would be twice as good as a score of 2. Time is a good example of a ratio scale. There is an absolute zero point (there is no such thing as negative time), the distance between 40 and 60 seconds is the same as the distance between 30 and 10 seconds. And 20 seconds is twice as long as 10 seconds. Another example, Fahrenheit is an interval scale because you can have negative degrees (e. g. -2 degrees below zero), while the Kelvin scale is a ratio scale because there is an absolute zero point and no negative numbers.

One other property of continuous variables is that they allow for different degrees of measurement precision. So for example, the continuous ratio variable of time can be measured in hours, minutes, seconds, milliseconds, etc. In contrast, a *discrete* variable can only take on a fixed measurement scale, like a rank scale of 1 to 10. The scale requires that you choose a value between 1 and 10, 2.5 is not possible.

## Scatterplot

Let's start by creating a simple scatterplot graph

```{r, eval=TRUE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x= displ, y=hwy))
```

There's a few things to learn here in the code

1.  ggplot is the basic command and within the parentheses is the data we'll be running our graph on
2.  geom_point is the type of graph will be using, geom stands for geometrical shape. So in this case we are making a graph of "points"
3.  The "mapping" argument lays out the variables we are graphing and is always paired with "aes". Finally x and y lay out which variables are going to be on our x and y axes.

So our basic formula looks lke this:

ggplot(data = <DATA>) + <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

### About the variables

If you look at the variables, you'll notice that hwy and displ are numbers and R views them as integers or whole numbers. Scatterplots usually require data that are numeric like this, numbers that go up in scale. So in this case scatterplots typically require **interval** or **ratio** data.

One peculiar thing about this graph is the group of numbers just above the numbers in the right corner. The general trend we see in these variables is that as displacement goes up (i.e. the engine uses more gasoline) the highway mileage goes down. This is sometimes referred to as a negative relationship. The cars with the best highway mileage displace the least amount of gasoline. However, there's a group of dots that range between 20 and 30 on the hwy variable, but seem to displace more gasoline than most. How can this be?

### Adding additional variables

One way we can answer this question is by adding in an additional variable. In this case the class or type of car. Let's add that in now as an additional variable to our graph.

```{r, eval=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

Notice how most of those dots are 2 seater cars. Thus, the reason they get better gas mileage is because they are smaller cars!!

Class is a particular kind of variable, in this case a **nominal** or *categorical* variable. r refers to them as characters. These are basically categories, so we can't do any math on them. You can't make a formula out of compact x midsize or minivan/pickup.

### Add Color

Let's do one more graph, but add a little color

```{r, eval=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

Notice how when the word "color" is outside the x and y mappings it changes the color of our points. You can try several different colors for the dots on your scatterplot.

## Bar Graphs

Let's learn one more graph, which is especially important for categorical variables, the bar graph.

First, check out the `diamonds` data set

```{r, eval=TRUE}
diamonds
```

The basics of the formula are going to be the same, but this time we are using `geom_bar` as our geometrical shape to create a bar graph.

```{r, eval=TRUE}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

If you look in section 3.7 in *R for Data Science* it explains what R is doing with the data

![](https://d33wubrfki0l68.cloudfront.net/70a3b18a1128c785d8676a48c005ee9b6a23cc00/7283c/images/visualization-stat-bar.png)

So R looks at the data set and automatically uses the *count* statistic to simply count the number of occurrences for that variable. So this only works for categorical variables.

Let's inspect the *cut* variable to see if this is true. Remember that the *`str`* command allows us to investigate the types of variables in the dataset.

```{r eval=TRUE}
str(diamonds)
```

Each of the variables are preceded by the *\$* sign. So we can see that *cut* is the second variable. Notice that it says cut is an `ord.factor with 5 levels`. This tells us that this variable is an **ordinal** variable because it is ordered based on the type of cut from fair (lowest type of cut) to ideal (the best type of cut).

### Another example

Here's another example from scratch. First I'll create a quick dataset using the `tribble` command.

```{r eval=TRUE}
Example <- tribble(
  ~group, ~number, 
  "Group 1", 30, 
  "Group 2", 50
)
```

Notice that our variable *group* is a categorical variable, but on it's own the stat *count* won't really tell us much (Group 1 = 1, Group 2 =1). So notice what happens when we try to make a bar graph like our last example.

```{r, eval=TRUE}
ggplot(data = Example) + 
  geom_bar(mapping = aes(x = group))
```

Doesn't really tell us much does it? So in this case the count has to be supplied by a second variable, *y*. When we use a *y* variable for our bar chart we have to use a different stat for the bar chart, in this case, the stat is *"identity"* so the code looks like this.

```{r, eval=TRUE}
ggplot(data = Example) +
  geom_bar(mapping = aes(x = group, y = number), stat = "identity")
```

Now it's easy to see the difference in count between Group 1 and Group 2
